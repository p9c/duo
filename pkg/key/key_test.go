package key

import (
	"crypto/sha256"
	"errors"
	"fmt"
	"testing"

	"github.com/parallelcointeam/duo/pkg/bc"
	"github.com/parallelcointeam/duo/pkg/buf"
	"github.com/parallelcointeam/duo/pkg/hash160"
)

func TestCryptPrivSig(t *testing.T) {
	fmt.Println()
	pass := []byte("password")
	var BC *bc.BlockCrypt
	BC = bc.New().Generate(buf.NewSecure().Copy(&pass).(*buf.Secure)).Arm()
	priv := NewPriv().WithBC(BC)
	priv.Make()
	priv.pub.Compress()
	address := hash160.Sum(priv.pub.Bytes())
	origPub := priv.pub.Bytes()
	fmt.Println("public key compr", *priv.pub.Bytes())
	priv.pub.Decompress()
	fmt.Println("public key uncmp", *priv.pub.Bytes())
	fmt.Println("private key as plaintext", *priv.Bytes())
	fmt.Println("content of buffer", *priv.Crypt.Bytes())
	var emptypriv *Priv
	emptypriv.WithBC(BC)
	fmt.Println(emptypriv.IsValid(), priv.IsValid())
	fmt.Println(emptypriv.Bytes())
	fmt.Println(emptypriv.Invalidate().Bytes())
	fmt.Println(emptypriv.Zero())
	fmt.Println(emptypriv.Make())
	fmt.Println(emptypriv.AsEC())
	fmt.Println(emptypriv.PubKey())
	fmt.Println("priv as EC", priv.AsEC())
	fmt.Println(priv.PubKey().Bytes())
	privB := buf.NewByte().Copy(priv.Bytes()).Bytes()
	pubB := buf.NewByte().Copy(priv.pub.Bytes()).Bytes()
	fmt.Println(privB, pubB)
	fmt.Println(priv.Invalidate().Bytes())
	priv = NewPriv().WithBC(BC)
	priv.SetKey(privB, pubB)
	fmt.Println(priv.Bytes())
	fmt.Println(priv.Crypt.Get().Bytes())
	out := priv.Bytes()
	fmt.Println("key as plaintext", *out)
	fmt.Println("content of buffer", *priv.Crypt.Bytes())
	emptypriv.Sign(nil)
	emptypriv.SignCompact(nil)
	priv.WithBC(BC)
	var oldaddress *[]byte
	for i := 0; i < 8; i++ {
		fmt.Print("\nROUND", i, "\n")
		priv = priv.Make()
		address = hash160.Sum(priv.pub.Bytes())
		fmt.Println("address", address)
		origPub = priv.PubKey().Bytes()
		if i%2 == 0 {
			priv.pub.Decompress()
		} else {
			priv.pub.Compress()
		}
		message := []byte("Testing signatures")
		fmt.Println("message", message)
		messageHash := sha256.Sum256(message)
		fmt.Println("hash   ", messageHash)
		mh := messageHash[:]
		full := priv.Sign(&mh)
		compact := priv.SignCompact(&mh)
		fmt.Println("full signature", full.Len(), full.Bytes())
		fmt.Println("compact signature", compact.Len(), compact.Bytes())
		var emptysig *Sig
		fmt.Println(emptysig.AsEC())
		fmt.Println(full.AsEC())
		fmt.Println(full.Error())
		fmt.Println(compact.AsEC())
		fmt.Println(compact.Error())
		fmt.Println("original public key ", origPub)
		c := compact.Recover(&mh, address)
		fmt.Println("From compact signature\nrecovered public key", c.Bytes())
		f := full.Recover(&mh, address)
		fmt.Println("From full signature\nrecovered public key", f.Bytes())
		fmt.Println(emptysig.Recover(&mh, address))
		fmt.Println(full.Recover(&mh, oldaddress))
		o := make([]byte, len(*address))
		copy(o, *address)
		oldaddress = &o
		full.Byte.Zero()
		compact.Byte.Zero()
		fmt.Println(full.Recover(&mh, address))
		fmt.Println(compact.Recover(&mh, address))
		fmt.Println(compact.Recover(nil, address))
	}
}

func TestPriv(t *testing.T) {
	var emptypriv *Priv
	var emptypub *Pub

	fmt.Println(emptypub.Bytes())

	priv := NewPriv()
	priv.Make()
	fmt.Println("priv", priv.Bytes())
	fmt.Println("pub ", priv.pub.Bytes())
	fmt.Println(emptypriv.Bytes())
	fmt.Println(priv.Bytes())
	fmt.Println(emptypub.AsCompressed().Bytes())
	fmt.Println(emptypub.Copy(nil))
	fmt.Println(priv.pub.Copy(nil))
	str := []byte("testingstring")
	fmt.Println(priv.pub.Copy(&[]byte{}))
	fmt.Println(priv.Copy(&str))
	fmt.Println(priv.pub.Copy(&str))
	fmt.Println(priv.Zero())
	fmt.Println(priv.pub.Zero())
	fmt.Println(emptypriv.Zero())
	fmt.Println(emptypub.Zero())
	fmt.Println(priv.Free())
	fmt.Println(emptypriv.Free())
	fmt.Println(priv.pub.Free())
	fmt.Println(emptypub.Free())
	priv = NewPriv()
	fmt.Println(priv.pub.GetID())
	fmt.Println(priv.GetID())
	fmt.Println(emptypub.GetID())
	fmt.Println(emptypriv.GetID())
	fmt.Println(priv.Make())
	fmt.Println(priv.pub.AsCompressed().Bytes())
	fmt.Println(priv.pub.AsUncompressed().Bytes())
	fmt.Println(priv.pub.AsHybrid().Bytes())
	priv.Make()
	fmt.Println(priv.pub.GetID())
	fmt.Println(priv.GetID())
	fmt.Println(priv.Make())
	fmt.Println("priv", priv.Bytes())
	fmt.Println("pub ", priv.pub.Bytes())
	fmt.Println(priv.pub.AsCompressed().Bytes())
	fmt.Println(priv.pub.AsUncompressed().Bytes())
	fmt.Println(priv.pub.AsHybrid().Bytes())
	fmt.Println(priv.pub.Zero().Bytes())
	fmt.Println(priv.pub.AsCompressed().Bytes())
	fmt.Println(priv.pub.AsUncompressed().Bytes())
	fmt.Println(priv.pub.AsHybrid().Bytes())
	fmt.Println(priv.PubKey())
	fmt.Println(priv.pub.AsEC())
	fmt.Println(priv.pub.Free())
	fmt.Println(priv.pub.Zero())
	priv.Zero()
	S := []byte("this is a test of thingy")
	mh := hash160.Sum(&S)
	priv.Crypt.Byte.Zero()
	fmt.Println(priv.Sign(mh).Bytes())
}

func TestPub(t *testing.T) {
	priv := NewPriv()
	priv.Make()
	pub := priv.pub
	fmt.Println(pub.IsCompressed())
	var emptypub *Pub
	fmt.Println(emptypub.IsCompressed())
	fmt.Println(emptypub.Compress())
	fmt.Println(emptypub.Decompress())
	fmt.Println(emptypub.AsCompressed())
	fmt.Println(emptypub.AsUncompressed())
	fmt.Println(emptypub.AsHybrid())
	fmt.Println(emptypub.AsEC())
	fmt.Println(emptypub.GetID())
	fmt.Println(pub.IsCompressed())
	fmt.Println(pub.Compress())
	fmt.Println(pub.Decompress())
	fmt.Println(pub.AsCompressed())
	fmt.Println(pub.AsUncompressed())
	fmt.Println(pub.AsHybrid())
	fmt.Println(pub.AsEC())
	fmt.Println(pub.GetID())
	fmt.Println(pub.Free())
	fmt.Println(pub.GetID())
}

func TestStore(t *testing.T) {
	var emptystore *Store
	store := NewStore()
	fmt.Println(emptystore)
	fmt.Println(store)
	fmt.Println(emptystore.SetStatus("testing"))
	fmt.Println(store.SetStatus("testing"))
	fmt.Println(emptystore.UnsetStatus())
	fmt.Println(store.UnsetStatus())
	fmt.Println(emptystore.SetStatusIf(errors.New("test")))
	fmt.Println(store.SetStatusIf(errors.New("test")))
	fmt.Println(emptystore.SetStatusIf(nil))
	fmt.Println(store.SetStatusIf(nil))
	fmt.Println(emptystore.OK())
	fmt.Println(store.OK())
	fmt.Println(emptystore.AddPriv(nil))
	fmt.Println(emptystore.AddPub(nil))
	fmt.Println(emptystore.Remove(""))
	pass := []byte("arbitrary thingy")
	BC := bc.New().Generate(buf.NewSecure().Copy(&pass).(*buf.Secure)).Arm()
	fmt.Println(emptystore.Encrypt(BC))
	fmt.Println(emptystore.Decrypt())
	fmt.Println(emptystore.Find(""))
	fmt.Println(store)
	fmt.Println(store.Encrypt(BC))
	fmt.Println(store.Decrypt())
	fmt.Println(store.Find(""))
	fmt.Println(store.AddPriv(nil))
	priv := NewPriv().WithBC(BC)
	priv.Make()
	fmt.Println(priv.Bytes())
	fmt.Println(store.AddPriv(priv))
	fmt.Println(store.AddPriv(priv))
	fmt.Println(store.AddPub(priv.pub))
	priv2 := NewPriv().WithBC(BC)
	priv2.Make()
	fmt.Println(priv2.Bytes())
	fmt.Println(store.AddPub(priv2.pub))
	fmt.Println(store.AddPub(priv2.pub))
	fmt.Println(store.Decrypt())
	fmt.Println(store.Encrypt(BC))
	fmt.Println(store.Find(priv.GetID()).Bytes())
	fmt.Println(store.Find(priv2.GetID()).Bytes())
	fmt.Println(store.Remove(priv.GetID()))
	fmt.Println(store.Remove(priv.GetID()))
	fmt.Println(store.Remove(priv2.GetID()))
	fmt.Println(store.Remove(priv2.GetID()))

}
